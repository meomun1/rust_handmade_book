# Unit Testing

## Basic Concepts 

Software testing can help with writing software that behaves correctly when implementing it, and also to ensure that software continues to behave correctly as we maintain the software. Rust allows you to write tests both very close to your code and from the perspective of someone consuming your code as a library. Although the definitions not always clear, the first form is often referred to as unit tests, and the second as integration tests.

# Unit Testing

1. ğŸ˜Š Upon generating a new library project using `cargo new --lib`, a source file `src/lib.rs` is generated. The file contains a library function `add(left: usize, right: usize) -> usize` and a test called `it_works` to verify that it works as expected.

    The source file looks something like this ğŸ‘‡

    ```rust 

    #![allow(unused)]
    fn main() {
    pub fn add(left: unsize, right: unsize ) -> unsize {
        left + right
    }
    #[cfg(test)]
        mod tests {
            use super::*;

            #[test]
            fn it_works() {
                let result = add(2, 2);
                assert_eq!(result, 4);
            }
        }
    }

    ```

    ğŸ˜€ You can run the tests immediately with `cargo test`

2. Adding Tests

    ```rust
    #![allow(unused)]
    fn main() {
        pub fn add(left: unsize, right: unsize ) -> unsize {
            left + left + right - right  // oops
        }
        #[cfg(test)]
        mob tests {
            use super::*; 

            #[test]
            fn adding_equal_numbers_works() {
            assert_eq!(add(2, 2), 4);
            }

            #[test]
            fn adding_unequal_numbers_works() {
            assert_eq!(add(2, 3), 5);
            }
        }
    }

    ```
    Running the tests now with the broken implementation shows that 
    tests::adding_unequal_numbers_works FAILED

3. The #[cfg(test)] annotation. The default code that is generated by cargo `new --lib` contains some code that is not strictly necessary. Setting up a unit test in Rust is very simple: just add a function annotated with `#[test]` and run `cargo test`

    For example, if you put the following into src/lib.rs

    ```rust 
    #![allow(unused)]
    fn main() {
    #[test]
    fn my_test() {}
    }

4. Explore why generated code includes annotation and module.

    #[cfg(test)] annotation tells the compiler only to include the code in the following item (which is a module named tests) when the feature flag test is enabled.

    Cargo allows you to define your feature flags in the Cargo.toml if you wanted to 

    The `test` feature flag automatically gets enabled when `cargo test` runs, making the code compile the contents of the `tests` module. A normal `cargo build` will not include the code in the `tests` module 

    It is good to realize that it is possible to omit the 
    #[cfg(test)] annotation entirely if desired. However, that would make the binary include the testing code, which is probably unnecessary.

    It is also good to realize that the module's name can be anything you wish, but it is usually named `tests`  by convention. If you need functionality in your tests but do not need it as part of the public API of your module, then you can implement the testing functionality within the test's module.

    This is done for the function `Database::at_10`

    ```rust 

    #![allow(unused)]
    fn main() {
    #[derive(Default)]
    pub struct Database {
        count: u32,
    }
    impl Database {
        pub fn operate(&mut self) {
            self.count += 1;
        }
    }
    #[cfg(test)]
    mob tests {
        use super::*;

        // Implement a functions only required for testing.
        impl Database {
            fn at_10() -> Database {
                Self { count: 10 }
            }
        }

        #[test]
        fn operate_once () {
            let mut database = Database::at_10();
            database.operate();
            assert_eq!(database.count, 11);
        }

        #[test]
        fn operating_twice () {
            let mut database = Database::at_10();
            database.operate();
            database.operate();
            assert_eq!(database.count, 12);
        }
    }
    }